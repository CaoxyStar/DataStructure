#include<iostream>
#include<string>
#include<vector>
using namespace std;

const int NUM = 34;  //省份总数
vector<int> Map_color(int, const int[NUM][NUM]);  //队列染色算法

int main()
{
	cout << "队列方法解决地图着色问题（以中国地图为例）" << endl;
	cout << "*********************************************" << endl;
	//存储各省名称
	string Province[NUM] = { "广西","广东","云南","贵州","湖南","江西","福建","浙江","安徽","湖北","重庆","四川","西藏",
		"青海","新疆","甘肃","陕西","宁夏","内蒙","北京","黑龙江","吉林","辽宁","天津","河北","山西","河南","江苏",
		"山东","上海","海南","台湾","香港","澳门" };
	//存储各省接壤信息的邻接矩阵
	int R[NUM][NUM] = {
		 {0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		 {1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		 {1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		 {1,0,1,0,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		 {1,1,0,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		 {0,1,0,0,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		 {0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		 {0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0},
		 {0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0},
		 {0,0,0,0,1,1,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0},
		 {0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		 {0,0,1,1,0,0,0,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		 {0,0,1,0,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		 {0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		 {0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		 {0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0},
		 {0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0},
		 {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0},
		 {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,0,0,0},
		 {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0},
		 {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0},
		 {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0},
		 {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0},
		 {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0},
		 {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,1,1,0,1,0,0},
		 {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0},
		 {0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,0},
		 {0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0},
		 {0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,0,0},
		 {0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0},
		 {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
	};
	vector<int>color_result = Map_color(NUM, R);

	//记录最少需用颜色数
	int min_color = 0;
	for (int i = 0; i < NUM; i++)
	{
		cout << Province[i] << "涂色为：" << color_result[i] << endl;
		if (color_result[i] > min_color)
			min_color = color_result[i];
	}
	cout << "***********************************************************" << endl;
	//打印涂色结果
	cout << "涂完中国地图最少需要" << min_color << "个颜色!" << endl;
	for (int i = 1; i <= min_color; i++)
	{
		cout << "涂色为" << i << "的省份有：";
		for (int j = 0; j < NUM; j++)
			if (color_result[j] == i)
				cout << Province[j] << ";";
		cout << endl;
	}
	system("pause");
	return 0;
}

//队列方法解决地图着色问题
vector<int> Map_color(int m, const int R[NUM][NUM])
{
	vector<int>cq(m);			//各省构成的待处理队列
	for (int i = 0; i < m; i++)
		cq[i] = i;
	vector<int>newr(m, 0);		//工作数组
	vector<int>Result(m, 0);	//存储各省涂色情况
	int front = m - 1;			//cq队列头指针
	int rear = m - 1;			//cq队列尾指针
	int pre = -1;				//记录上次处理元素的编号
	int group = 1;				//记录当先分组颜色序号
	int I;						//记录上次处理省份编号

	do
	{
		front = (front + 1) % m;
		I = cq[front];
		if (I < pre)				//开辟新组并更新newr数组
		{
			group++;
			Result[I] = group;
			for (int i = 0; i < m; i++)
				newr[i] = R[I][i];
		}
		else
		{
			if (newr[I] != 0)		//被处理省份不可被选择
			{
				rear = (rear + 1) % m;
				cq[rear] = I;
			}
			else					//被处理省份可以被选择
			{
				Result[I] = group;
				for (int i = 0; i < m; i++)
					if (R[I][i] == 1)
						newr[i] = 1;
			}
		}
		pre = I;					//根据上次被处理省份的编号更新值
	} while (rear != front);

	return Result;
}